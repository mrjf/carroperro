#!/usr/bin/env python
"""Functions to build count structures from car-dog hashtag coocurrence data"""

import os
import json
from collections import defaultdict
import csv
from carroperro.util import name_from_hashtag


def build_counts_from_coocs(cooc_path, cars, dogs):
    """Walk the tree of json cooc files and build a dict of dicts of the
    form:

    {car1: {dog1: count, dog2: count, ...}, car2: {dog1: count,...}...}

    The keys of the outer dict are all the car names, and the values are
    dictionaries from dog names to counts. The counts correspond to the
    number of times that dog name occurred as a hashtag in the same user
    timeline as the hashtag for that car name (or vice versa).

    Args:
        cooc_path: location of the directory that contains the coocurrence
            data for cars and dogs, with each file being named after a
            hashtag and contain a JSON dict from hashtag: count
        cars: an instance of Cars
        dogs: an instance of Dogs

        Returns:
            defaultdict: of (defaultdict(int)), cooc structure described above

        """

    counts = defaultdict(lambda: defaultdict(int))

    for root, dirs, files in os.walk(cooc_path):
        for file in files:
            print(file)
            if file[-5:] == '.json':
                print(cooc_path + '/' + file)
                type_a, name_a = name_from_hashtag(file[:-5], cars, dogs)
                print('name_a', name_a)
                with open(cooc_path + '/' + file, 'r') as f:
                    coocs = json.loads(f.read())
                    for hashtag, count in coocs.items():
                        type_b, name_b = name_from_hashtag(hashtag, cars, dogs)
                        if type_a != type_b:
                            if type_a == 'car':
                                counts[name_a][name_b] += count
                            else:
                                counts[name_b][name_a] += count

    # json roundtrip turns nested defaultdict structure into normal dicts
    return json.loads(json.dumps(counts))


def reverse_counts(counts):
    """Create a dog-oriented view of the counts:

    {dog1: {car1: count, car2: count, ...}, dog2: {car1: count,...}...}

    Args:
        counts (dict): the car-oriented counts as created by
            build_counts_from_coocs

    Returns:
        dict: the counts re-cast to have dogs as the first-level key

    """

    new = defaultdict(lambda: defaultdict(int))

    for car, dog_counts in counts.items():
        for dog, count in dog_counts.items():
            new[dog][car] += count

    return json.loads(json.dumps(new))


def write_counts_csv(counts, csv_path):
    """Takes a dictionary of dictionaries of counts and writes a CSV file
    from them. Could use csvwriter for more safety, but we know we have
    no problematic values in our names and no escaping needed.

    Args:
        counts: dict of dicts as generated by build_counts_from_coocs
        csv_path: location to write csv file
    """

    with open(csv_path, 'w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=['car', 'dog', 'count'])
        writer.writeheader()
        for car, dog_counts in counts.items():
            for dog, count in dog_counts.items():
                writer.writerow({'car': car, 'dog': dog, 'count': str(count)})


def read_count_csv(csv_path):
    """Reads the csv file written by write_csv_from_countsand returns the count
    structure built by build_counts_from_coocs
    """

    counts = defaultdict(lambda: defaultdict(int))

    with open(csv_path, 'r', newline='') as f:
        reader = csv.DictReader(f)
        for row in reader:
            counts[row['car']][row['dog']] += int(row['count'])

    return json.loads(json.dumps(counts))
